{% extends "scan_layout.html" %}
{% block title %}Scan Small Bags{% endblock %}
{% block header %}üì¶ Scan SMALL Bags{% endblock %}

{% block styles %}
.progress-card {
    background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
    color: white;
    border-radius: 20px;
    padding: 25px;
    margin: 15px 0;
}

.big-number {
    font-size: 72px;
    font-weight: bold;
    text-align: center;
    line-height: 1;
}

.progress-label {
    font-size: 24px;
    text-align: center;
    margin-top: 10px;
}

.scan-box {
    background: white;
    border-radius: 20px;
    padding: 25px;
    margin: 20px 0;
}

.scan-input {
    font-size: 28px;
    padding: 18px;
    text-align: center;
    border: 4px solid #2196F3;
    border-radius: 15px;
    font-weight: bold;
    text-transform: uppercase;
    width: 100%;
    outline: none;
}

.scan-input:focus {
    border-color: #4CAF50;
    box-shadow: 0 0 25px rgba(76, 175, 80, 0.5);
}

.scan-input:disabled {
    background: #f0f0f0;
    border-color: #ccc;
}

.progress-bar {
    height: 40px;
    border-radius: 20px;
    background: #e0e0e0;
    overflow: hidden;
    margin: 20px 0;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
    transition: width 0.5s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
    font-weight: bold;
}

.item {
    background: #f8f9fa;
    border-left: 5px solid #4CAF50;
    padding: 15px;
    margin: 10px 0;
    border-radius: 10px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.item-num {
    background: #4CAF50;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.party {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #333;
    border-radius: 20px;
    padding: 40px 25px;
    text-align: center;
    margin: 20px 0;
    animation: pop 0.6s ease;
}

@keyframes pop {
    0% { transform: scale(0.8); opacity: 0; }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); opacity: 1; }
}

.party h2 {
    font-size: 36px;
    margin-bottom: 15px;
}

@media (max-width: 480px) {
    .big-number { font-size: 60px; }
    .progress-label { font-size: 20px; }
    .scan-input { font-size: 24px; padding: 16px; }
}
{% endblock %}

{% block content %}
<div class="container">
    {% if parent_qr %}
    <div class="progress-card">
        <div class="big-number" id="count">{{ scanned_child_count }}</div>
        <div class="progress-label">out of 30 small bags</div>
        <div style="text-align: center; margin-top: 15px; font-size: 18px;">
            Big Bag: <strong>{{ parent_qr }}</strong>
        </div>
    </div>
    
    <div class="progress-bar">
        <div class="progress-fill" id="bar" style="width: {{ (scanned_child_count / 30 * 100) }}%;">
            {{ scanned_child_count }}/30
        </div>
    </div>
    
    <div class="scan-box">
        <h3 style="text-align: center; color: #2196F3; margin-bottom: 20px;">
            üì¶ Scan Small Bag
        </h3>
        
        <form id="form">
            <input 
                type="text" 
                id="input" 
                class="scan-input" 
                placeholder="READY" 
                autocomplete="off"
                autofocus
            >
        </form>
        
        <div style="text-align: center; margin-top: 15px; color: #666; font-size: 16px;">
            <div id="status">‚úÖ Ready</div>
        </div>
        
        <div style="text-align: center; margin-top: 15px;">
            <button 
                id="undo-btn" 
                onclick="undoLast()" 
                class="btn btn-secondary" 
                style="padding: 12px 30px; display: none;"
            >
                ‚Ü∂ Remove Last Scan
            </button>
        </div>
    </div>
    
    <div style="margin: 20px 0;">
        <h4 style="color: #666; margin-bottom: 15px;">üìã Recently Scanned</h4>
        <div id="list">
            {% if linked_child_bags %}
                {% for child in linked_child_bags|reverse %}
                <div class="item">
                    <div style="display: flex; align-items: center;">
                        <div class="item-num">{{ loop.revindex }}</div>
                        <strong style="margin-left: 15px; font-size: 20px;">{{ child.qr_id }}</strong>
                    </div>
                    <span style="color: #4CAF50; font-size: 24px;">‚úÖ</span>
                </div>
                {% endfor %}
            {% else %}
                <div id="empty" style="text-align: center; color: #999; padding: 30px;">
                    No bags scanned yet
                </div>
            {% endif %}
        </div>
    </div>
    
    <div id="party" class="party" style="display: none;">
        <h2>‚≠ê Complete! ‚≠ê</h2>
        <p style="font-size: 24px; margin: 15px 0;">All 30 small bags done!</p>
        <p style="font-size: 18px; margin-bottom: 25px;">Big Bag <strong>{{ parent_qr }}</strong> is ready</p>
        <button onclick="nextBag()" class="btn btn-success" style="width: 100%; max-width: 400px; min-height: 60px;">
            ‚ñ∂ Next Big Bag
        </button>
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
        <a href="/scan/parent" class="btn btn-secondary" style="padding: 12px 30px;">
            ‚¨Ö Back
        </a>
    </div>
    
    {% else %}
    <div style="background: #fff3cd; text-align: center; font-size: 20px; padding: 30px; margin: 30px 0; border-radius: 15px;">
        <div style="font-size: 48px; margin-bottom: 15px;">‚ö†Ô∏è</div>
        <strong>Please scan a big bag first!</strong>
        <div style="margin-top: 20px;">
            <a href="/scan/parent" class="btn btn-primary" style="width: 100%; max-width: 400px; min-height: 60px;">
                üì¶ Scan Big Bag
            </a>
        </div>
    </div>
    {% endif %}
</div>

<audio id="beep" preload="auto">
    <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS57OihUxILTKXo86xbGAg+ltrzxnUsCSB0xPDekT4JEU+m4fCrWBUIQ5zm8r5sIQQrhM/y2Yo3CRdnvOznpE8SC0ml5PKsWhgHPJXZ88p4LAceb8Tv3JA+CQ9Op+HwqVkUCEGa5fK/ayEEKYPP8tuJNwgUY7vt56NRFA1Jpejxq1oYBjuV2fPKeCwGHm7E79yQPgkPTqfh8KpZFAhBmuXyv2wgBSiDz/LbiTcIE2K57OajUxQOSaXo8atbGAc7lNjzyngsBS1txa/ckT4KD06o4fCqWhUIQZvm8sBsIQQogdDy24k3CBNiuezno1MUDkml6PGsWxcHO5TX88p3LAUtbcOu3JE+ChBOp+Lwq1sXCECa5fLAbCEEJoLQ8dqKOAgTYrrs6KNSFQ9Ip+fxrVsZCDuU2PPKeCwGLW3DrtySPwoQTajh8qtbGAg/mubywGwiBSaB0PHaijkIE2K67OejUxQPSKfn8KxcGQc7ldfzyHUsBy1txK/djD8JD0+n4fGsWxkIP5rm8r9sIwUlgNDy24o6CBRisuzoo1MVDUZL4fGsXRoIN5PY88l2LAgtbMSu3Y0/Cw9PqODyq1saCj2a5vK/bSQFJIDQ8duKOwkUYrLs56NUFg5FSeDxrV4aBzqT2PPJWK2EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"></source>
</audio>
{% endblock %}

{% block scripts %}
<script>
const input = document.getElementById('input');
const countEl = document.getElementById('count');
const bar = document.getElementById('bar');
const status = document.getElementById('status');
const list = document.getElementById('list');
const party = document.getElementById('party');
const beep = document.getElementById('beep');

let count = {{ scanned_child_count }};
let processing = false;
let lastScanned = '';
let lastScanTime = 0;
let scannedCodes = new Set();

// Pre-populate scanned codes from existing list
{% if linked_child_bags %}
{% for child in linked_child_bags %}
scannedCodes.add('{{ child.qr_id }}'.toUpperCase());
{% endfor %}
{% endif %}

function playBeep() {
    if (beep) {
        beep.currentTime = 0;
        beep.play().catch(e => console.log('Audio failed:', e));
    }
}

function updateDisplay(newCount) {
    count = newCount;
    if (countEl) countEl.textContent = count;
    if (bar) {
        const pct = (count / 30 * 100);
        bar.style.width = pct + '%';
        bar.textContent = count + '/30';
    }
}

function addItem(qr) {
    const empty = document.getElementById('empty');
    if (empty) empty.remove();
    
    const qrUpper = qr.toUpperCase();
    if (scannedCodes.has(qrUpper)) return;
    
    scannedCodes.add(qrUpper);
    
    const item = document.createElement('div');
    item.className = 'item';
    item.innerHTML = `
        <div style="display: flex; align-items: center;">
            <div class="item-num">${count}</div>
            <strong style="margin-left: 15px; font-size: 20px;">${qr}</strong>
        </div>
        <span style="color: #4CAF50; font-size: 24px;">‚úÖ</span>
    `;
    list.insertBefore(item, list.firstChild);
}

async function process(qr) {
    if (processing || !qr || count >= 30) return;
    
    const qrUpper = qr.toUpperCase();
    
    // Client-side duplicate check
    if (scannedCodes.has(qrUpper)) {
        showToast('‚ö†Ô∏è Already scanned: ' + qr, 'warning');
        vibrate([100, 50, 100]);
        input.value = '';
        input.focus();
        return;
    }
    
    // Prevent rapid double-scans within 1 second
    const now = Date.now();
    if (qr === lastScanned && now - lastScanTime < 1000) {
        input.value = '';
        return;
    }
    
    lastScanned = qr;
    lastScanTime = now;
    processing = true;
    input.disabled = true;
    status.innerHTML = '‚è≥ Processing...';
    status.style.color = '#FF9800';
    
    // Set timeout to prevent hanging
    const timeout = setTimeout(() => {
        processing = false;
        input.disabled = false;
        input.value = '';
        input.focus();
        showToast('‚è±Ô∏è Timeout. Try again.', 'warning');
        status.innerHTML = '‚úÖ Ready';
        status.style.color = '#666';
    }, 10000);
    
    try {
        const r = await fetch('/process_child_scan_fast', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ qr_code: qr })
        });
        
        clearTimeout(timeout);
        const d = await r.json();
        
        if (d.success) {
            playBeep();
            updateDisplay(d.child_count || count + 1);
            addItem(qr);
            showToast('‚úÖ ' + qr + ' added!', 'success');
            status.innerHTML = '‚úÖ Success!';
            status.style.color = '#4CAF50';
            
            // Track for undo
            lastScannedQr = qr;
            const undoBtn = document.getElementById('undo-btn');
            if (undoBtn) undoBtn.style.display = 'inline-block';
            
            if (d.child_count >= 30) {
                setTimeout(() => {
                    if (party) {
                        party.style.display = 'block';
                        party.scrollIntoView({ behavior: 'smooth' });
                        vibrate([200, 100, 200, 100, 400]);
                    }
                }, 500);
            }
        } else {
            showToast('‚ùå ' + (d.message || 'Error'), 'error');
            status.innerHTML = '‚ö†Ô∏è Try again';
            status.style.color = '#f44336';
            vibrate([200, 100, 200]);
        }
    } catch (err) {
        clearTimeout(timeout);
        console.error(err);
        
        // Queue for offline processing
        if (!isOnline || err.message.includes('fetch')) {
            if (offlineQueue.add({ qr: qr, type: 'child' })) {
                showToast('üì° Offline - queued for sync', 'info');
                status.innerHTML = 'üì§ Queued';
                status.style.color = '#FF9800';
                
                // Optimistically add to UI
                count++;
                updateDisplay(count);
                addItem(qr);
            } else {
                showToast('‚ùå Failed to queue', 'error');
                status.innerHTML = '‚ö†Ô∏è Error';
                status.style.color = '#f44336';
            }
        } else {
            showToast('üì° Network error', 'warning');
            status.innerHTML = '‚ö†Ô∏è Error';
            status.style.color = '#f44336';
        }
    } finally {
        processing = false;
        input.disabled = false;
        input.value = '';
        input.focus();
        
        setTimeout(() => {
            if (status.innerHTML !== '‚úÖ Success!') {
                status.innerHTML = '‚úÖ Ready';
                status.style.color = '#666';
            }
        }, 2000);
    }
}

function nextBag() {
    window.location.href = '/scan/parent';
}

let lastScannedQr = null;

async function undoLast() {
    // If we don't have the QR code in memory, confirm generically
    const confirmMsg = lastScannedQr 
        ? `Remove ${lastScannedQr}?` 
        : 'Remove the most recent scan?';
    
    if (!confirm(confirmMsg)) return;
    
    const undoBtn = document.getElementById('undo-btn');
    if (undoBtn) undoBtn.disabled = true;
    
    try {
        // Get CSRF token from meta tag
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
        const headers = { 'Content-Type': 'application/json' };
        if (csrfToken) {
            headers['X-CSRFToken'] = csrfToken;
        }
        
        // Send QR code if we have it, otherwise let server determine most recent
        const requestBody = lastScannedQr 
            ? { qr_code: lastScannedQr }
            : {};
        
        const r = await fetch('/api/unlink_child', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });
        
        const d = await r.json();
        
        if (d.success) {
            // Remove from UI
            const items = list.querySelectorAll('.item');
            if (items.length > 0) {
                items[0].remove();
            }
            
            // Update count
            count = d.child_count || count - 1;
            updateDisplay(count);
            
            // Remove from scanned set
            scannedCodes.delete(lastScannedQr.toUpperCase());
            
            showToast('‚úÖ Removed: ' + lastScannedQr, 'success');
            lastScannedQr = null;
            if (undoBtn) undoBtn.style.display = 'none';
        } else {
            showToast('‚ùå ' + (d.message || 'Cannot remove'), 'error');
        }
    } catch (err) {
        console.error(err);
        showToast('üì° Network error', 'warning');
    } finally {
        if (undoBtn) undoBtn.disabled = false;
    }
}

document.getElementById('form').addEventListener('submit', function(e) {
    e.preventDefault();
    const qr = input.value.trim().toUpperCase();
    if (qr) process(qr);
});

// Process offline queue
async function processQueue() {
    const processed = await offlineQueue.processAll(async (item) => {
        try {
            const r = await fetch('/process_child_scan_fast', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ qr_code: item.qr })
            });
            const d = await r.json();
            if (d.success) {
                updateDisplay(d.child_count || count + 1);
                addItem(item.qr);
                return true;
            }
            return false;
        } catch (e) {
            return false;
        }
    });
    
    if (processed > 0) {
        showToast(`‚úÖ Synced ${processed} scans`, 'success');
        playBeep();
    }
}

// Check and process queue on load
setTimeout(() => {
    const queuedCount = offlineQueue.getAll().length;
    if (queuedCount > 0 && isOnline) {
        showToast(`üì§ ${queuedCount} scans queued - syncing...`, 'info');
        processQueue();
    } else if (count < 30) {
        showToast('üì± Ready to scan!', 'info');
    }
}, 500);

keepFocus(input);

// Show undo button if there are scanned bags
const undoBtn = document.getElementById('undo-btn');
if (count > 0 && undoBtn) {
    undoBtn.style.display = 'inline-block';
}

if (count >= 30 && party) {
    party.style.display = 'block';
    input.disabled = true;
}
</script>
{% endblock %}
